{"version":3,"sources":["FlexModelUtils.ts","LoadTemplate.ts","App.tsx","index.tsx"],"names":["getConfig","tab","getType","TabNode","TYPE","Error","getId","max","dimension1","dimension2","result","Math","isNaN","setTabSetSize","tabset","updateIfNeeded","safeToSetWidth","widthNeeded","undefined","widthPreferred","width","console","log","getChildren","forEach","node","getName","preferredWidth","minWidth","attrs","getMinWidth","currentWidth","getWidth","Object","keys","length","setSize","Actions","updateNodeAttributes","getModel","doAction","analyseRow","row","setWidth","tabsetChildren","filter","TabSetNode","getOrientation","Orientation","HORZ","ts","RowNode","childRowPreferredWidth","analyseModel","modelToAnalyse","alsoSetWidth","size","getRoot","model","removeTabset","maxPanelNr","maxPanel","panels","Map","panelNr","visitNodes","set","childrenToMove","child","tabToDestination","dest","mv","p","get","destMajor","moveNode","DockLocation","CENTER","destMinor","destPref","del","deleteTabset","reorderTabs","tabsToMove","panelPreferences","floor","abs","round","taskTemplateLayout","global","layout","loadTemplateModel","fullModel","initialModel","Model","fromJson","adaptedModel","availableWidth","window","innerWidth","nrPanels","App","useState","currentModel","setCurrentModel","maxPanels","setMaxPanels","className","value","onChange","event","parseInt","target","onAction","action","setTimeout","onModelChange","factory","component","getComponent","dangerouslySetInnerHTML","__html","text","style","height","overflow","src","border","scrolling","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"oOAWMA,G,MAAY,SAACC,GACf,GAAIA,EAAIC,YAAcC,UAAQC,KAC1B,OAAQH,EAAmBD,YAE3B,MAAMK,MAAM,QAAD,OAASJ,EAAIK,QAAb,gDAKbC,EAAM,SAACC,EAAgCC,GACzC,IAAIC,EAASC,KAAKJ,IAAIC,EAAaC,GACnC,OAAIG,MAAMF,GACFF,IACAC,QACJ,GAEOC,GAKTG,EAAgB,SAACC,EAAoBC,GAA2E,IAAlDC,EAAiD,wDAC3GN,EAAsB,CACxBO,iBAAaC,EACbC,oBAAgBD,EAChBE,WAAOF,GAyBX,GAvBAG,QAAQC,IAAI,eAEZR,EAAOS,cAAcC,SAAQ,SAAAC,GACzB,GAAIA,EAAKvB,YAAcC,UAAQC,KAC3B,MAAMC,MAAM,gEAGhB,IAAMJ,EAAMwB,EACZJ,QAAQC,IAAR,cAAmBrB,EAAIyB,UAAvB,gBAAwCzB,EAAID,YAAY2B,iBACxDjB,EAAOO,YAAcV,EAAIG,EAAOO,YAAajB,EAAUC,GAAK2B,UAC5DlB,EAAOU,MAAQb,EAAIG,EAAOU,MAAOpB,EAAUC,GAAKmB,OAChDV,EAAOS,eAAiBZ,EAAIG,EAAOS,eAAgBnB,EAAUC,GAAK0B,mBAGjEjB,EAAOS,iBACJT,EAAOU,MACPV,EAAOS,eAAiBT,EAAOU,MAE/BV,EAAOS,eAAiBT,EAAOO,aAKnCF,EAAgB,CAMhB,IAAMc,EAAe,GACjBnB,EAAOO,aAAeP,EAAOO,YAAc,GAAKH,EAAOgB,gBAAkBpB,EAAOO,cAChFY,EAAMD,SAAWlB,EAAOO,aAE5B,IAAMc,EAAejB,EAAOkB,WAc5B,IAbKhB,GAAkBe,EAEnBF,EAAMT,MAAQ,WACNW,GAAgBf,GAAkBN,EAAOU,OAASW,IAAiBrB,EAAOU,QAKlFS,EAAMT,MAAQV,EAAOU,OAKrBa,OAAOC,KAAKL,GAAOM,OAAS,EAAG,CAC/B,IAAMC,EAAUC,UAAQC,qBAAqBxB,EAAOR,QAASuB,GAC7DR,QAAQC,IAAI,QAASD,QAAQC,IAAIO,GACjCf,EAAOyB,WAAWC,SAASJ,IAKnC,OAFAf,QAAQC,IAAI,uBAAwBD,QAAQC,IAAIZ,GAChDW,QAAQC,IAAI,iBACLZ,GAIL+B,EAAa,SAAbA,EAAcC,EAAc3B,GAAsE,IAChGY,EAAiB,EACjBgB,GAAW,EAETC,EAAiBF,EAAInB,cAAcsB,QAAO,SAACpB,GAAD,OAAUA,EAAKvB,YAAc4C,aAAW1C,QAyBxF,OAxBIwC,EAAeT,QAAU,GAAKpB,GAAkB2B,EAAIK,mBAAqBC,cAAYC,OACrFN,GAAW,GAGfD,EAAInB,cAAcC,SAAQ,SAAAC,GACtB,GAAIA,EAAKvB,YAAc4C,aAAW1C,KAAM,CACpC,IAAM8C,EAAKrC,EAAcY,EAAoBV,EAAgB4B,GAEzDD,EAAIK,mBAAqBC,cAAYC,KACrCtB,GAAkBuB,EAAG/B,eAAiB+B,EAAG/B,eAAiB+B,EAAGjC,YAE7DU,EAAiBpB,EAAIoB,EAAgBuB,EAAG/B,eAAiB+B,EAAG/B,eAAiB+B,EAAGjC,kBAEjF,GAAIQ,EAAKvB,YAAciD,UAAQ/C,KAAM,CAExC,IAAMgD,EAAyBX,EAAWhB,EAAiBV,EAAgB4B,GACvED,EAAIK,mBAAqBC,cAAYC,KACrCtB,GAAkByB,EAElBzB,EAAiBpB,EAAIoB,EAAgByB,OAK1CzB,GAGE0B,EAAe,SAACC,GAA0G,IAAnFvC,IAAkF,yDAAlDwC,EAAkD,wDAG5HC,EAAOf,EAAWa,EAAeG,UAAW1C,EAAgBwC,GAE5D7C,EAAyB,CAC3BgD,MAAOJ,EACPnC,eAAgBqC,GAIpB,OADAnC,QAAQC,IAAIZ,GACLA,GAiBEiD,EAAe,SAACD,EAAcE,GACvC,IAAIC,EACEC,EAAS,IAAIC,IAIfC,EAAU,EASd,OARAN,EAAMO,YAAW,SAACxC,GACd,GAAuB,WAAnBA,EAAKvB,UAAwB,CAC7B,IAAMgD,EAAKzB,EACXqC,EAAOI,IAAIF,IAAWd,OAG9BW,EAAYD,GAA2BE,EAAON,KAE1CM,EAAON,KAAO,IASlBM,EAAOtC,SAAQ,SAAC0B,EAAIc,GAChB,GAAIA,GAAWH,EAAU,CAErB,IAAMM,EAAiB,IAAIJ,IAC3Bb,EAAG3B,cAAcC,SAAQ,SAAC4C,GACtB,GAAwB,QAApBA,EAAMlE,UAAqB,CAC3B,IAAMD,EAAMmE,EACZD,EAAeD,IAAIjE,EAAKoE,EAAiBpE,EAAK4D,EAAW,QAIjEM,EAAe3C,SAAQ,SAAC8C,EAAMF,GAC1B,IACIG,EADAC,EAAIV,EAAOW,IAAIH,EAAKI,WAGpBH,EADAC,EACKnC,UAAQsC,SAASP,EAAM9D,QAASkE,EAAGlE,QAASsE,eAAaC,OAAQP,EAAKQ,UAAY,IAAIR,EAAKS,UAAWT,EAAKS,SAAW,GAGtH1C,UAAQsC,SAASP,EAAM9D,QAASoD,EAAMD,UAAUnD,QAASsE,eAAaC,QAAU,GAAG,GAE5FnB,EAAMlB,SAAS+B,MAOnB,IAAIS,EAAM3C,UAAQ4C,aAAa/B,EAAG5C,SAClCoD,EAAMlB,SAASwC,OAKvBE,EAAYxB,IAxCDA,GA6CTwB,EAAc,SAACxB,GACjB,IAAMI,EAAS,IAAIC,IAGfC,EAAU,EACdN,EAAMO,YAAW,SAACxC,GACd,GAAuB,WAAnBA,EAAKvB,UAAwB,CAC7B,IAAMgD,EAAKzB,EACXqC,EAAOI,IAAIF,IAAWd,OAK9B,IAAMiC,EAAa,IAAIpB,IACvBL,EAAMO,YAAW,SAACxC,GACS,QAAnBA,EAAKvB,WACLiF,EAAWjB,IAAIzC,EAAiB4C,EAAiB5C,EAAiBqC,EAAON,UAMjF2B,EAAW3D,SAAQ,SAAC8C,EAAMrE,GACtB,IAAIsE,EAEJ,GAAuB,IAAnBD,EAAKI,UAAiB,CACtB,IAAIF,EAAIV,EAAOW,IAAIH,EAAKI,WAEpBF,IACAD,EAAKlC,UAAQsC,SAAS1E,EAAIK,QAASkE,EAAGlE,QAASsE,eAAaC,OAAQP,EAAKQ,UAAY,IAAIR,EAAKS,UAAWT,EAAKS,SAAW,GACzHrB,EAAMlB,SAAS+B,SAgBzBF,EAAmB,SAACpE,GAAqD,IAAD,IACtE8E,EADgClB,EAAsC,uDAAnB,EAGvD,IAAI,UAAA7D,EAAUC,UAAV,mBAAgBmF,wBAAhB,eAAkCjD,SAAU0B,EAAU,CACtDkB,EAAW/E,EAAUC,GAAKmF,iBAAiBvB,EAAW,GACtD,IAAMa,EAAY/D,KAAK0E,MAAM1E,KAAK2E,IAAIP,IAChCD,EAAYnE,KAAK4E,MAAO5E,KAAK2E,IAAIP,KAAcL,EAAa,EAAuC,IAAlC/D,KAAK2E,IAAIP,GAAYL,IAE5F,MAAO,CACHK,WACAL,YACAI,aAGJ,MAAO,CACHC,WACAL,UAAW,EACXI,WAAY,ICnRpBU,EAEO,CACHC,OAAQ,CACJ,yBAA2B,GAK/BC,OAAQ,CACJ,KAAQ,MAER,SAAY,CACR,CACI,KAAQ,SACR,SAAY,EACZ,SAAY,CACR,CACI,KAAQ,MACR,KAAQ,OACR,UAAa,MACb,aAAe,EACf,OAAU,CACN,KAAQ,uDACR,SAAY,GACZ,eAAkB,IAClB,iBAAoB,CAAC,IAAK,IAAK,IAAK,IAAK,SAKzD,CACI,KAAQ,SACR,SAAY,EACZ,SAAY,CACR,CACI,KAAQ,MACR,KAAQ,SACR,UAAa,MACb,aAAe,EACf,OAAU,CACN,KAAQ,wDACR,SAAY,GACZ,eAAkB,IAClB,iBAAoB,EAAE,KAAM,IAAK,IAAK,IAAK,SAK3D,CACI,KAAQ,SACR,SAAY,EACZ,SAAY,CACR,CACI,KAAQ,MACR,KAAQ,SACR,UAAa,MACb,aAAe,EACf,OAAU,CACN,KAAQ,+FACR,SAAY,GACZ,eAAkB,IAClB,iBAAoB,EAAE,KAAM,KAAM,IAAK,IAAK,SAM5D,CACI,KAAQ,SACR,SAAY,EACZ,SAAY,CACR,CACI,KAAQ,MACR,KAAQ,MACR,UAAa,QACb,aAAe,EACf,OAAU,CACN,KAAQ,kGACR,SAAY,IACZ,UAAa,IACb,eAAkB,IAClB,iBAAoB,EAAE,KAAM,KAAM,KAAM,IAAK,SAK7D,CACI,KAAQ,SACR,SAAY,EACZ,SAAY,CACR,CACI,KAAQ,MACR,KAAQ,QACR,UAAa,WACb,aAAe,EACf,OAAU,CACN,KAAQ,gCACR,MAAS,KACT,SAAY,IACZ,eAAkB,KAClB,iBAAoB,EAAE,IAAK,IAAK,IAAK,IAAK,YAmD7DC,EAAoB,SAAC9B,GAC9B,IAEI+B,EAFAC,EAAeC,QAAMC,SAASP,GAC9BQ,EAAeH,EAKnB,GAAIhC,EACAmC,EAAerC,EAAakC,EAAchC,EAAW,GAErD+B,EAAYvC,EAAa2C,GAAc,GAAM,OAE1C,CACH,IAAMC,EAAiBC,OAAOC,WAG9BP,EAAYvC,EAAawC,GAAc,GAAM,GAE7C,IAAIO,EAAW,EAIf,IAHAR,EAAUlC,MAAMO,YAAW,SAACxC,GAAeA,EAAKvB,YAAc4C,aAAW1C,MAAMgG,OAGxEA,EAAW,GAAKH,EAAiBL,EAAUzE,gBAC9C6E,EAAerC,EAAaiC,EAAUlC,MAAO0C,GAC7CR,EAAYvC,EAAa2C,GAAc,GAAM,GAC7CI,IAKR,OAAOR,G,OCzFIS,MAvFf,WAGE,MAAwCC,oBAAyB,WAC/D,OAAOX,OADT,mBAAOY,EAAP,KAAqBC,EAArB,KAGA,EAAkCF,mBAAS,GAA3C,mBAAOG,EAAP,KAAkBC,EAAlB,KA0DA,OACE,sBAAKC,UAAU,QAAf,UACE,sDACA,yBAAQC,MAAOH,EAAWI,SAfX,SAACC,GAClBJ,EAAaK,SAASD,EAAME,OAAOJ,QACnCJ,EAAgBb,EAAkBoB,SAASD,EAAME,OAAOJ,UAatD,UACE,wBAAQA,MAAM,IAAd,eACA,wBAAQA,MAAM,IAAd,eACA,wBAAQA,MAAM,IAAd,eACA,wBAAQA,MAAM,IAAd,eACA,wBAAQA,MAAM,IAAd,kBAEF,qBAAKD,UAAU,QAAf,SACGJ,GACC,cAAC,SAAD,CACEU,SArCc,SAACC,GASvB,OAJAC,YAAW,WACTX,EAAgBnD,EAAakD,EAAa7C,OAAO,MAChD,KAEIwD,GA6BCE,cArBW,SAAC1D,GACpB8C,EAAgBnD,EAAakD,EAAa7C,OAAO,KAqBzCA,MAAO6C,EAAa7C,MACpB2D,QAxEM,SAAC5F,GACf,IAAI6F,EAAY7F,EAAK8F,eACrB,GAAkB,SAAdD,EACF,OAAO,qBAAKE,wBAAyB,CAAEC,OAAQhG,EAAKzB,YAAY0H,QAC3D,GAAkB,QAAdJ,EAAqB,CAY9B,OAAO,sBAAKK,MALC,CACXC,OAAQ,OACRxG,MAAO,OACPyG,SAAU,UAEL,eAAoB,wBAAQC,IAAKrG,EAAKzB,YAAY0H,KAAMf,UAAU,sBAAsBgB,MAX/E,CACdC,OAAQ,MACRxG,MAAO,MACPyG,SAAU,SACVE,OAAQ,QAOqGC,UAAU,OAAlH,OACF,GAAkB,UAAdV,EAAuB,CAKhC,OAAO,qBAAKQ,IAAKrG,EAAKzB,YAAY0H,KAAMC,MAJ9B,CACRC,OAAQ,MACRxG,MAAO,SAGJ,GAAkB,aAAdkG,EAA0B,CAKnC,OAAO,qBAAKQ,IAAKrG,EAAKzB,YAAY0H,KAAMC,MAJ9B,CACRvG,MAAO,SACPwG,OAAQ,sBC1ChBK,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,gB","file":"static/js/main.c59c97aa.chunk.js","sourcesContent":["import { Model, TabNode, TabSetNode, Orientation, Actions, Action, Node as FLNode, DockLocation, RowNode } from 'flexlayout-react';\r\nimport { IAnalyzedModel, IDimensions } from './types';\r\n\r\ninterface IConfig {\r\n    width: number | undefined,\r\n    minWidth: number | undefined,\r\n    panelPreferences: number[],\r\n    preferredWidth: number | undefined\r\n}\r\n\r\n// typesafe access to avoid typos in code\r\nconst getConfig = (tab: FLNode): IConfig => {\r\n    if (tab.getType() === TabNode.TYPE) {\r\n        return (tab as TabSetNode).getConfig() as IConfig;\r\n    } else {\r\n        throw Error(`Node ${tab.getId()} is not a tab and so does not have config`)\r\n    }\r\n}\r\n\r\n// return the max, taking into account that either or both might be undefined\r\nconst max = (dimension1: number | undefined, dimension2: number | undefined): number | undefined => {\r\n    let result = Math.max(dimension1!, dimension2!);\r\n    if (isNaN(result)) {\r\n        if (dimension1) return dimension1;\r\n        if (dimension2) return dimension2;\r\n        return undefined\r\n    } else {\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\nconst setTabSetSize = (tabset: TabSetNode, updateIfNeeded: boolean, safeToSetWidth: boolean = false): IDimensions => {\r\n    const result: IDimensions = {\r\n        widthNeeded: undefined,\r\n        widthPreferred: undefined,\r\n        width: undefined\r\n    };\r\n    console.log(\"-----------\")\r\n    // iterate through the tabs to get sizes\r\n    tabset.getChildren().forEach(node => {\r\n        if (node.getType() !== TabNode.TYPE) {\r\n            throw Error(\"tabset has a child which is not a tab - this is not expected\")\r\n        }\r\n\r\n        const tab = node as TabNode;\r\n        console.log(`tab ${tab.getName()} has ${tab.getConfig().preferredWidth}`)\r\n        result.widthNeeded = max(result.widthNeeded, getConfig(tab).minWidth);\r\n        result.width = max(result.width, getConfig(tab).width);\r\n        result.widthPreferred = max(result.widthPreferred, getConfig(tab).preferredWidth);\r\n    })\r\n\r\n    if (!result.widthPreferred) {\r\n        if (result.width) {\r\n            result.widthPreferred = result.width;\r\n        } else {\r\n            result.widthPreferred = result.widthNeeded;\r\n        }\r\n    }\r\n\r\n    // to avoid infinite loops, updates cannot be done on model updates\r\n    if (updateIfNeeded) {\r\n        // only modify if different because this causes a model update which again causes analyse\r\n        type Attrs = {\r\n            minWidth?: number,\r\n            width?: number\r\n        };\r\n        const attrs: Attrs = {};\r\n        if (result.widthNeeded && result.widthNeeded > 0 && tabset.getMinWidth() !== result.widthNeeded) {\r\n            attrs.minWidth = result.widthNeeded;\r\n        }\r\n        const currentWidth = tabset.getWidth();\r\n        if (!safeToSetWidth && currentWidth) {\r\n            // Reset the width or there will be layout problems\r\n            attrs.width = 999999999;  // only way to clear an already-set width\r\n        } else if (!currentWidth && safeToSetWidth && result.width && currentWidth !== result.width) {\r\n            // if the current width is undefined (otherwise the user has set it and we'd better leave it alone)\r\n            // and it is safe to set the width (there are other tabsets to use free space)\r\n            // and there IS a width to set and its new\r\n            // only then: set the width\r\n            attrs.width = result.width;\r\n        }\r\n\r\n\r\n        // Now set the size information collated from the child tabs at the tabset level in the model\r\n        if (Object.keys(attrs).length > 0) {\r\n            const setSize = Actions.updateNodeAttributes(tabset.getId(), attrs);\r\n            console.log(\"===>\"); console.log(attrs);\r\n            tabset.getModel().doAction(setSize);\r\n        }\r\n    }\r\n    console.log(\"tabset has prefferd\"); console.log(result);\r\n    console.log(\"=============\")\r\n    return result;\r\n}\r\n\r\n// returns preferred width (defaulting to the min width if there is no prefferd) of all tabsets in the row\r\nconst analyseRow = (row: RowNode, updateIfNeeded: boolean, safeToSetWidth: boolean = false): number => {\r\n    let preferredWidth = 0;\r\n    let setWidth = false;\r\n\r\n    const tabsetChildren = row.getChildren().filter((node) => node.getType() === TabSetNode.TYPE);\r\n    if (tabsetChildren.length >= 2 && updateIfNeeded && row.getOrientation() === Orientation.HORZ) {\r\n        setWidth = true; // can only do this if there enough tabsets\r\n    }\r\n\r\n    row.getChildren().forEach(node => {\r\n        if (node.getType() === TabSetNode.TYPE) {\r\n            const ts = setTabSetSize(node as TabSetNode, updateIfNeeded, setWidth);\r\n\r\n            if (row.getOrientation() === Orientation.HORZ) {\r\n                preferredWidth += ts.widthPreferred ? ts.widthPreferred : ts.widthNeeded!;\r\n            } else {\r\n                preferredWidth = max(preferredWidth, ts.widthPreferred ? ts.widthPreferred : ts.widthNeeded)!;\r\n            }\r\n        } else if (node.getType() === RowNode.TYPE) {\r\n            // recurse for child row\r\n            const childRowPreferredWidth = analyseRow(node as RowNode, updateIfNeeded, setWidth);\r\n            if (row.getOrientation() === Orientation.HORZ) {\r\n                preferredWidth += childRowPreferredWidth;\r\n            } else {\r\n                preferredWidth = max(preferredWidth, childRowPreferredWidth)!;\r\n            }\r\n        }\r\n    })\r\n\r\n    return preferredWidth;\r\n}\r\n\r\nexport const analyseModel = (modelToAnalyse: Model, updateIfNeeded: boolean = true, alsoSetWidth: boolean = false): IAnalyzedModel => {\r\n\r\n    // call analyze row with root\r\n    const size = analyseRow(modelToAnalyse.getRoot(), updateIfNeeded, alsoSetWidth);\r\n\r\n    const result: IAnalyzedModel = {\r\n        model: modelToAnalyse,\r\n        widthPreferred: size\r\n    }\r\n\r\n    console.log(result);\r\n    return result;\r\n}\r\n\r\n\r\nexport const cloneModel = (modelToClone: IAnalyzedModel): IAnalyzedModel => {\r\n    let saveCurrentJson = modelToClone.model.toJson();\r\n    let clone = { ...modelToClone };\r\n    clone.model = Model.fromJson(saveCurrentJson);\r\n    return clone;\r\n}\r\n\r\n\r\n\r\n// 1. find the tabsets within the model and put them into a map based on their panel number\r\n// 2. for each panel, if its panel nr is larger than max panel then it needs to be deleted but not before...\r\n// 3. ...moving its children to their preferred destination specified in panelPreferences.\r\n// The child nodes are then moved to their new preferred / available panel\r\nexport const removeTabset = (model: Model, maxPanelNr?: number): Model => {\r\n    let maxPanel = -1;\r\n    const panels = new Map<number, TabSetNode>();\r\n\r\n\r\n    // first find out how many tabsets there are in the model and collect them in a map. \r\n    let panelNr = 1;\r\n    model.visitNodes((node) => {\r\n        if (node.getType() === 'tabset') {\r\n            const ts = node as TabSetNode;\r\n            panels.set(panelNr++, ts);\r\n        }\r\n    });\r\n    maxPanel = (maxPanelNr) ? maxPanelNr : panels.size;\r\n\r\n    if (panels.size < 2) {\r\n        // don't want to delete the last tabset, so bail out here\r\n        return model;\r\n    }\r\n\r\n    // Now delete the top N tabsets\r\n    // if this function is called without a maxPanelNr then that's just the last panel (e.g. 5)\r\n    // if this function is called with a maxPanelNr (cos we're loading a template and the user only wants e.g. 2 panels) then that could be more than 1\r\n\r\n    panels.forEach((ts, panelNr) => {\r\n        if (panelNr >= maxPanel) {\r\n            // move the children\r\n            const childrenToMove = new Map<TabNode, Destination>();\r\n            ts.getChildren().forEach((child) => {\r\n                if (child.getType() === 'tab') {\r\n                    const tab = child as TabNode;\r\n                    childrenToMove.set(tab, tabToDestination(tab, maxPanel - 1));\r\n                }\r\n            })\r\n\r\n            childrenToMove.forEach((dest, child) => {\r\n                let p = panels.get(dest.destMajor);\r\n                let mv;\r\n                if (p) {\r\n                    mv = Actions.moveNode(child.getId(), p!.getId(), DockLocation.CENTER, dest.destMinor - 1, (dest.destPref ? dest.destPref > 0 : false) /* +ve = selected */);\r\n                } else {\r\n                    // got to move it somewhere....then to root\r\n                    mv = Actions.moveNode(child.getId(), model.getRoot().getId(), DockLocation.CENTER, - 1, false);\r\n                }\r\n                model.doAction(mv);\r\n            })\r\n\r\n\r\n            // delete the tabset. Actually an empty tabset will not be rendered\r\n            // but this will confuse the task of finding next tab to remove\r\n            // so better to clean up\r\n            let del = Actions.deleteTabset(ts.getId());\r\n            model.doAction(del);\r\n        }\r\n    })\r\n\r\n    // With less tabsets, some other tabs might prefer to be moved\r\n    reorderTabs(model);\r\n    return model;\r\n}\r\n\r\n// move tabs if necessary so that they are all on their preferred panel, in the preferred order\r\nconst reorderTabs = (model: Model) => {\r\n    const panels = new Map<number, TabSetNode>();\r\n\r\n    // first find out how many tabsets there are in the model \r\n    let panelNr = 1;\r\n    model.visitNodes((node) => {\r\n        if (node.getType() === 'tabset') {\r\n            const ts = node as TabSetNode;\r\n            panels.set(panelNr++, ts);\r\n        }\r\n    });\r\n\r\n    // Now iterate through the tabs and see where to move them\r\n    const tabsToMove = new Map<TabNode, Destination>();\r\n    model.visitNodes((node) => {\r\n        if (node.getType() === 'tab') {\r\n            tabsToMove.set(node as TabNode, tabToDestination(node as TabNode, panels.size));\r\n        }\r\n    });\r\n\r\n\r\n    // now do the moves\r\n    tabsToMove.forEach((dest, tab) => {\r\n        let mv;\r\n\r\n        if (dest.destMajor !== 0) {\r\n            let p = panels.get(dest.destMajor);\r\n            // tabOrder is the number after the decimal point\r\n            if (p) {\r\n                mv = Actions.moveNode(tab.getId(), p!.getId(), DockLocation.CENTER, dest.destMinor - 1, (dest.destPref ? dest.destPref > 0 : false) /* +ve = selected */);\r\n                model.doAction(mv);\r\n            }\r\n        }\r\n\r\n    })\r\n\r\n\r\n}\r\n\r\n\r\n// use tab config to see, for the given max panel, where the tab should go\r\ntype Destination = {\r\n    destPref: number | undefined, // the original config value (can be negative or undefined)\r\n    destMajor: number, // 0 means unknown destination\r\n    destMinor: number\r\n}\r\nconst tabToDestination = (tab: TabNode, maxPanel: number = 5): Destination => {\r\n    let destPref;\r\n\r\n    if (getConfig(tab)?.panelPreferences?.length >= maxPanel) {\r\n        destPref = getConfig(tab).panelPreferences[maxPanel - 1];\r\n        const destMajor = Math.floor(Math.abs(destPref));\r\n        const destMinor = Math.round((Math.abs(destPref) === destMajor) ? 0 : (Math.abs(destPref) - destMajor) * 10);\r\n\r\n        return {\r\n            destPref,\r\n            destMajor,\r\n            destMinor\r\n        }\r\n    } else {\r\n        return {\r\n            destPref,\r\n            destMajor: 0,\r\n            destMinor: -1\r\n        }\r\n    }\r\n\r\n}","import { Model, IJsonModel, TabSetNode } from 'flexlayout-react';\r\n\r\nimport { analyseModel, removeTabset } from './FlexModelUtils';\r\nimport { IAnalyzedModel, IDimensions } from './types';\r\n\r\n\r\n\r\nvar taskTemplateLayout: { name: string, model: IJsonModel } = {\r\n    name: 'task1',\r\n    model: {\r\n        global: {\r\n            \"rootOrientationVertical\": false,\r\n            // \"tabSetEnableDivide\": false, // it keeps things simpler for moving tabs if all tabsets are labelled with a panel nr\r\n            // \"enableEdgeDock\": false, // otherwise the user can create new rows by dragging into the edge\r\n            //\"tabEnableClose\": false\r\n        }, // {tabSetEnableTabStrip:false}, // to have just splitters\r\n        layout: {\r\n            \"type\": \"row\",\r\n\r\n            \"children\": [\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"Comm\",\r\n                            \"component\": \"pdf\",\r\n                            \"enableClose\": false,\r\n                            \"config\": {\r\n                                \"text\": \"https://www.ibm.com/downloads/cas/GB8ZMQZ3#view=FitH\",\r\n                                \"minWidth\": 50,\r\n                                \"preferredWidth\": 150,\r\n                                \"panelPreferences\": [1.1, 1.1, 1.1, 1.1, 1.1]\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"Letter\",\r\n                            \"component\": \"pdf\",\r\n                            \"enableClose\": false,\r\n                            \"config\": {\r\n                                \"text\": \"https://ai.stanford.edu/~nilsson/MLBOOK.pdf#view=FitH\",\r\n                                \"minWidth\": 50,\r\n                                \"preferredWidth\": 150,\r\n                                \"panelPreferences\": [-1.3, -1.3, 2.1, 2.1, 2.1]\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"Claims\",\r\n                            \"component\": \"pdf\",\r\n                            \"enableClose\": false,\r\n                            \"config\": {\r\n                                \"text\": \"https://patentimages.storage.googleapis.com/68/80/73/6a17a66e9ec8c5/US11107588.pdf#view=FitH\",\r\n                                \"minWidth\": 50,\r\n                                \"preferredWidth\": 150,\r\n                                \"panelPreferences\": [-1.4, -2.2, -3.2, 3.1, 3.1]\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"Fig\",\r\n                            \"component\": \"image\",\r\n                            \"enableClose\": false,\r\n                            \"config\": {\r\n                                \"text\": \"https://patentimages.storage.googleapis.com/US20060145019A1/US20060145019A1-20060706-D00000.png\",\r\n                                \"minWidth\": 250,\r\n                                \"minHeight\": 350,\r\n                                \"preferredWidth\": 250,\r\n                                \"panelPreferences\": [-1.2, -1.2, -1.2, -1.2, 4.1]\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"AppAn\",\r\n                            \"component\": \"123check\",\r\n                            \"enableClose\": true,\r\n                            \"config\": {\r\n                                \"text\": \"/flexstack2/123Check_only.png\",\r\n                                \"width\": 1280,\r\n                                \"minWidth\": 774,\r\n                                \"preferredWidth\": 1280,\r\n                                \"panelPreferences\": [-1.5, 2.1, 3.1, 4.1, 5.1]\r\n                            }\r\n                        }\r\n                    ]\r\n                }\r\n            ]\r\n        }\r\n    }\r\n};\r\n\r\n\r\nconst getDimensions = (mfe: string): IDimensions => {\r\n    // hard coded for now....\r\n\r\n    switch (mfe) {\r\n        case 'pdf':\r\n            return {\r\n                widthNeeded: 50,\r\n                widthPreferred: undefined,\r\n                width: undefined\r\n            }\r\n            break;\r\n        case '123check':\r\n            return {\r\n                widthNeeded: 774,\r\n                widthPreferred: 1280,\r\n                width: 1280\r\n            }\r\n\r\n            break;\r\n        case 'image':\r\n            return {\r\n                widthNeeded: 250,\r\n                widthPreferred: undefined,\r\n                width: undefined\r\n            }\r\n\r\n            break;\r\n        default:\r\n            return {\r\n                widthNeeded: undefined,\r\n                widthPreferred: undefined,\r\n                width: undefined\r\n            }\r\n            break;\r\n    }\r\n}\r\n\r\n\r\n// if maxPanel is undefined, return the canonical model (or in future the user's saved model if there is one, and the canonical model failing that)\r\n// if maxPanel is defined, transform the model \r\nexport const loadTemplateModel = (maxPanel?: number) => {\r\n    let initialModel = Model.fromJson(taskTemplateLayout.model as IJsonModel);\r\n    let adaptedModel = initialModel;\r\n    let fullModel: IAnalyzedModel;\r\n\r\n\r\n    // if the caller has specified the nr of panels, then return a model that meets that requirement\r\n    if (maxPanel) {\r\n        adaptedModel = removeTabset(initialModel, maxPanel + 1);\r\n\r\n        fullModel = analyseModel(adaptedModel, true, true);\r\n\r\n    } else { // I have to figure out myself how many panels fit the current viewport\r\n        const availableWidth = window.innerWidth;\r\n\r\n\r\n        fullModel = analyseModel(initialModel, true, true);\r\n        // see how many panels there are in the full model\r\n        let nrPanels = 0;\r\n        fullModel.model.visitNodes((node) => { if (node.getType() === TabSetNode.TYPE) nrPanels++ });\r\n\r\n        // remove tabset one by one until it fits\r\n        while (nrPanels > 1 && availableWidth < fullModel.widthPreferred) {\r\n            adaptedModel = removeTabset(fullModel.model, nrPanels);\r\n            fullModel = analyseModel(adaptedModel, true, true);\r\n            nrPanels--;\r\n        }\r\n\r\n    }\r\n\r\n    return fullModel;\r\n\r\n}","import React, { useEffect, useRef, useState } from 'react';\r\nimport './App.css';\r\nimport 'flexlayout-react/style/light.css'\r\n\r\nimport { Layout, Model, TabNode, Action, DockLocation } from 'flexlayout-react';\r\n\r\nimport { analyseModel } from './FlexModelUtils';\r\n\r\n\r\nimport { loadTemplateModel } from './LoadTemplate'\r\nimport { IAnalyzedModel } from './types';\r\n\r\n\r\nfunction App() {\r\n  // currentModel is what we're currently rendering.\r\n  // If we need to alter the layout due to size restrictions, the previous state is saved in \"stashedModels\" so that it can be restored later\r\n  const [currentModel, setCurrentModel] = useState<IAnalyzedModel>(() => {\r\n    return loadTemplateModel()\r\n  });\r\n  const [maxPanels, setMaxPanels] = useState(5);\r\n\r\n  const factory = (node: TabNode) => {\r\n    var component = node.getComponent();\r\n    if (component === \"text\") {\r\n      return <div dangerouslySetInnerHTML={{ __html: node.getConfig().text }} />\r\n    } else if (component === \"pdf\") {\r\n      const iStyles = {\r\n        height: '99%',\r\n        width: '99%',\r\n        overflow: 'hidden',\r\n        border: 'none'\r\n      }\r\n      const cont = {\r\n        height: '100%',\r\n        width: '100%',\r\n        overflow: 'hidden'\r\n      }\r\n      return <div style={cont}>  <iframe src={node.getConfig().text} className=\"invisible-scrollbar\" style={iStyles} scrolling=\"no\" /> </div>\r\n    } else if (component === \"image\") {\r\n      const s = {\r\n        height: '99%',\r\n        width: '99%'\r\n      }\r\n      return <img src={node.getConfig().text} style={s} />\r\n    } else if (component === \"123check\") {\r\n      const s = {\r\n        width: '1200px',\r\n        height: '1000px'\r\n      }\r\n      return <img src={node.getConfig().text} style={s} />\r\n    }\r\n  }\r\n\r\n  const interceptAction = (action: Action) => {\r\n\r\n    // when tabs are moved by the user, this can lead to a \"divide\" whereby a new tabset is created automatically for the tab\r\n    // this new tabset will not have a minimum size and so this needs to be set\r\n    // also for deletion of tabs or addition of nodes, the size may be impacted\r\n    setTimeout(() => {\r\n      setCurrentModel(analyseModel(currentModel.model, true /* update min sizes if needed*/));\r\n    }, 100);\r\n\r\n    return action;\r\n  }\r\n\r\n  const loadPanels = (event: any) => {\r\n    setMaxPanels(parseInt(event.target.value));\r\n    setCurrentModel(loadTemplateModel(parseInt(event.target.value)));\r\n  }\r\n\r\n  const modelChanged = (model: Model) => {\r\n    setCurrentModel(analyseModel(currentModel.model, false /* avoid infintie loop*/))\r\n  }\r\n\r\n\r\n\r\n\r\n  return (\r\n    <div className=\"outer\">\r\n      <span> Number of Panels:</span>\r\n      <select value={maxPanels} onChange={loadPanels}>\r\n        <option value=\"1\">1</option>\r\n        <option value=\"2\">2</option>\r\n        <option value=\"3\">3</option>\r\n        <option value=\"4\">4</option>\r\n        <option value=\"5\">5</option>\r\n      </select>\r\n      <div className=\"inner\" >\r\n        {currentModel && (\r\n          <Layout\r\n            onAction={interceptAction}\r\n            onModelChange={modelChanged}\r\n            model={currentModel.model}\r\n            factory={factory} />)}\r\n      </div>\r\n    </div>\r\n\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('container')\n);\n"],"sourceRoot":""}