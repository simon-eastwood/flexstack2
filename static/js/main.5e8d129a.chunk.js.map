{"version":3,"sources":["FlexModelUtils.ts","hooks/useMediaQuery.ts","LoadTemplate.ts","App.tsx","index.tsx"],"names":["setTabSetSize","tabset","updateIfNeeded","alsoSetWidth","heightNeeded","widthNeeded","width","widthPreferred","getChildren","forEach","node","getType","TabNode","TYPE","Error","t","Math","max","getConfig","minHeight","minWidth","attrs","getMinWidth","getMinHeight","currentWidth","getWidth","console","log","Object","keys","length","setSize","Actions","updateNodeAttributes","getId","getModel","doAction","analyseRow","row","alsoUpdateWidth","setWidth","tabsetChildren","filter","TabSetNode","ts","getOrientation","Orientation","HORZ","RowNode","size","analyseModel","modelToAnalyse","lowestPrioTabset","undefined","activeTabset","getRoot","visitNodes","toLowerCase","isActive","result","model","cloneModel","modelToClone","saveCurrentJson","toJson","clone","Model","fromJson","moveTabset","panels","Map","panelNr","panel","set","mv","moveNode","get","DockLocation","BOTTOM","removeTabset","maxPanelNr","maxPanel","childrenToMove","child","tab","tabToDestination","dest","p","destMajor","CENTER","destMinor","destPref","del","deleteTabset","reorderTabs","tabsToMove","panelPreferences","floor","abs","round","createUseMedia","effect","query","defaultState","useState","state","setState","mounted","mediaQueryList","window","matchMedia","onChange","Boolean","matches","addListener","removeListener","useMedia","useEffect","useLayoutEffect","taskTemplateLayout","global","layout","loadTemplateModel","howToStack","fullModel","initialModel","adaptedModel","availableWidth","innerWidth","nrPanels","App","stashedModels","_setStashedModels","maxPanels","setMaxPanels","height","canvasToggleAbs","setCanvasToggleAbs","stackStrategy","layoutRef","useRef","currentModel","stashSet","isTooNarrow","stackDirection","alteredModel","previousModelWidth","newStash","m","push","downsizeModel","tooWide","isTooWide","sourceModel","targetModel","lastTabSet","actions","getNodeById","deleteTab","parent","getParent","addNode","RIGHT","action","migrateModel","slice","stashPop","absStyle","className","style","value","event","parseInt","target","ref","onAction","setTimeout","onModelChange","factory","component","getComponent","dangerouslySetInnerHTML","__html","text","overflow","src","border","scrolling","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.5e8d129a.chunk.js","sourcesContent":["import { Model, TabNode, TabSetNode, Orientation, Actions, Action, Node as FLNode, DockLocation, RowNode } from 'flexlayout-react';\r\nimport { Simulate } from 'react-dom/test-utils';\r\n\r\n\r\n\r\n\r\nexport interface IAnalyzedModel {\r\n    model: Model,\r\n    activeTabset: FLNode | undefined,\r\n    widthNeeded?: number,\r\n    width?: number,\r\n    widthPreferred?: number,\r\n    heightNeeded?: number\r\n}\r\n\r\ninterface IDimensions {\r\n    widthNeeded: number,\r\n    heightNeeded: number,\r\n    widthPreferred: number,\r\n    width: number\r\n}\r\n\r\n\r\nconst setTabSetSize = (tabset: TabSetNode, updateIfNeeded: boolean, alsoSetWidth: boolean = false): IDimensions => {\r\n    let heightNeeded = 0;\r\n    let widthNeeded = 0;\r\n    let width = -1;\r\n    let widthPreferred = -1;\r\n\r\n    // iterate through the tabs to get min sizes\r\n    tabset.getChildren().forEach(node => {\r\n        if (node.getType() !== TabNode.TYPE) {\r\n            throw Error(\"tabset has a child which is not a tab - this is not expected\")\r\n        }\r\n\r\n        const t = node as TabNode;\r\n        heightNeeded = Math.max(heightNeeded, t.getConfig().minHeight ? t.getConfig().minHeight : -1);\r\n        widthNeeded = Math.max(widthNeeded, t.getConfig().minWidth ? t.getConfig().minWidth : -1);\r\n        width = Math.max(width, t.getConfig().width ? t.getConfig().width : -1);\r\n        widthPreferred = Math.max(widthPreferred, t.getConfig().widthPreferred ? t.getConfig().widthPreferred : -1);\r\n    })\r\n\r\n    // to avoid infinite loops, updates cannot be done on model updates\r\n    if (updateIfNeeded) {\r\n        // only modify if different because this causes a model update which again causes analyse\r\n\r\n        type Attrs = {\r\n            minWidth?: number,\r\n            minHeight?: number,\r\n            width?: number\r\n        };\r\n        const attrs: Attrs = {};\r\n        if (widthNeeded > 0 && tabset.getMinWidth() !== widthNeeded) {\r\n            attrs.minWidth = widthNeeded;\r\n        }\r\n        if (heightNeeded > 0 && tabset.getMinHeight() !== heightNeeded) {\r\n            attrs.minHeight = heightNeeded;\r\n        }\r\n        const currentWidth = tabset.getWidth();\r\n        if (width > 0 && !currentWidth) {\r\n            if (alsoSetWidth) {\r\n                // set the width of the tabset\r\n                attrs.width = width;\r\n            } else {\r\n                ;\r\n            }\r\n\r\n            console.log(\"SETTING WIDTH\");\r\n        } else if (currentWidth && currentWidth > 0 && !alsoSetWidth) {\r\n            attrs.width = 999999999;\r\n        }\r\n        // Now set the size information collated from the child tabs at the tabset level in the model\r\n        if (Object.keys(attrs).length > 0) {\r\n            const setSize = Actions.updateNodeAttributes(tabset.getId(), attrs);\r\n            console.log(\"===>\"); console.log(attrs);\r\n            tabset.getModel().doAction(setSize);\r\n        }\r\n    }\r\n\r\n    return {\r\n        widthNeeded,\r\n        heightNeeded,\r\n        width,\r\n        widthPreferred\r\n    }\r\n\r\n}\r\n\r\nconst analyseRow = (row: RowNode, updateIfNeeded: boolean, alsoUpdateWidth: boolean = false): IDimensions => {\r\n    let widthNeeded = 0;\r\n    let heightNeeded = 0;\r\n    let width = 0;\r\n    let widthPreferred = 0;\r\n    let setWidth = alsoUpdateWidth;\r\n\r\n    const tabsetChildren = row.getChildren().filter((node) => node.getType() === TabSetNode.TYPE);\r\n    if (tabsetChildren.length >= 2 && updateIfNeeded) {\r\n        setWidth = true; // can only do this if too few tabsets\r\n    }\r\n\r\n    row.getChildren().forEach(node => {\r\n        if (node.getType() === TabSetNode.TYPE) {\r\n            const ts = setTabSetSize(node as TabSetNode, updateIfNeeded, setWidth);\r\n\r\n            if (row.getOrientation() === Orientation.HORZ) {\r\n                widthNeeded += ts.widthNeeded;\r\n                width += ts.width;\r\n                heightNeeded = Math.max(heightNeeded, ts.heightNeeded);\r\n                widthPreferred += ts.widthPreferred ? ts.widthPreferred : (ts.width > 0 ? ts.width : ts.widthNeeded);\r\n            } else {\r\n                widthNeeded = Math.max(widthNeeded, ts.widthNeeded);\r\n                width = Math.max(width, ts.width);\r\n                widthPreferred = Math.max(widthPreferred, ts.widthPreferred);\r\n                heightNeeded += ts.heightNeeded;\r\n            }\r\n        } else if (node.getType() === RowNode.TYPE) {\r\n            // recurse for child row\r\n            const size = analyseRow(node as RowNode, updateIfNeeded, setWidth);\r\n            if (row.getOrientation() === Orientation.HORZ) {\r\n                if (size.widthNeeded) widthNeeded += size.widthNeeded;\r\n                if (size.width) width += size.width;\r\n                if (size.widthPreferred) widthPreferred += size.widthPreferred;\r\n                if (size.heightNeeded) heightNeeded = Math.max(heightNeeded, size.heightNeeded);\r\n            } else {\r\n                if (size.widthNeeded) widthNeeded = Math.max(widthNeeded, size.widthNeeded);\r\n                if (size.width) widthNeeded = Math.max(widthNeeded, size.width);\r\n                if (size.widthPreferred) widthPreferred = Math.max(widthPreferred, size.widthPreferred);\r\n                if (size.heightNeeded) heightNeeded += size.heightNeeded;\r\n            }\r\n        }\r\n    })\r\n\r\n\r\n    return {\r\n        widthNeeded,\r\n        heightNeeded,\r\n        widthPreferred,\r\n        width\r\n    }\r\n}\r\n\r\nexport const analyseModel = (modelToAnalyse: Model, updateIfNeeded: boolean = true, alsoSetWidth: boolean = false): IAnalyzedModel => {\r\n\r\n    let lowestPrioTabset: TabSetNode | undefined = undefined;\r\n    let activeTabset: TabSetNode | undefined = undefined;\r\n\r\n\r\n    // call analyze row with root\r\n    const size = analyseRow(modelToAnalyse.getRoot(), updateIfNeeded, alsoSetWidth);\r\n\r\n    // post processing\r\n    modelToAnalyse.visitNodes(node => {\r\n        if (!lowestPrioTabset && node.getType().toLowerCase() === 'tabset') lowestPrioTabset = node as TabSetNode;\r\n\r\n        if (!activeTabset && node.getType().toLowerCase() === 'tabset' && (node as TabSetNode).isActive()) {\r\n            activeTabset = node as TabSetNode;\r\n        }\r\n\r\n\r\n    });\r\n\r\n\r\n    const result: IAnalyzedModel = {\r\n        model: modelToAnalyse,\r\n        activeTabset: activeTabset,\r\n        widthNeeded: size.widthNeeded,\r\n        width: size.width,\r\n        widthPreferred: size.widthPreferred,\r\n        heightNeeded: size.heightNeeded\r\n    }\r\n\r\n    console.log(\"updateifneeded? \" + updateIfNeeded);\r\n    console.log(result);\r\n    return result;\r\n}\r\n\r\n\r\nexport const cloneModel = (modelToClone: IAnalyzedModel): IAnalyzedModel => {\r\n    let saveCurrentJson = modelToClone.model.toJson();\r\n    let clone = { ...modelToClone };\r\n    clone.model = Model.fromJson(saveCurrentJson);\r\n    return clone;\r\n}\r\n\r\n\r\n\r\nexport const migrateModel = (sourceModel: IAnalyzedModel, targetModel: IAnalyzedModel) => {\r\n    let actions: Action[] = [];\r\n    let lastTabSet: TabSetNode;\r\n\r\n    // Which nodes need to be deleted from target?\r\n    targetModel.model.visitNodes((node) => {\r\n        if (node.getType() === TabNode.TYPE) {\r\n            if (!sourceModel.model.getNodeById(node.getId())) {\r\n                actions.push(Actions.deleteTab(node.getId()));\r\n            }\r\n        } else if (node.getType() === TabSetNode.TYPE) {\r\n            lastTabSet = node as TabSetNode;\r\n        }\r\n    })\r\n\r\n    // which nodes need to added to the target?\r\n    sourceModel.model.visitNodes((node) => {\r\n        if (node.getType() === TabNode.TYPE) {\r\n            if (!targetModel.model.getNodeById(node.getId())) {\r\n                // add to the same parent if possible\r\n                const parent = node.getParent();\r\n                if (parent!.getType() === TabSetNode.TYPE && targetModel.model.getNodeById(parent!.getId())) {\r\n                    actions.push(Actions.addNode(node.toJson(), parent!.getId(), DockLocation.CENTER, -1, false));\r\n                } else {\r\n                    // Otherwise add to the last tabset in the model\r\n                    if (lastTabSet) {\r\n                        actions.push(Actions.addNode(node.toJson(), lastTabSet.getId(), DockLocation.CENTER, -1, false));\r\n                    } else {\r\n                        actions.push(Actions.addNode(node.toJson(), targetModel.model.getRoot().getId(), DockLocation.RIGHT, -1, false));\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n    });\r\n\r\n    actions.forEach(action => {\r\n        targetModel.model.doAction(action);\r\n    });\r\n}\r\n\r\nexport const moveTabset = (model: Model): Model => {\r\n    const panels = new Map<number, TabSetNode>();\r\n\r\n    let panelNr = 1;\r\n    model.visitNodes((node) => {\r\n        if (node.getType() === 'tabset') {\r\n            if ((node as TabSetNode).getConfig()?.panel) {\r\n                const ts = node as TabSetNode;\r\n                panels.set(panelNr++, ts);\r\n            }\r\n        }\r\n    });\r\n\r\n    if (panels.size < 2) {\r\n        // can't move the  last tabset, so bail out here\r\n        return model;\r\n    }\r\n\r\n    let mv = Actions.moveNode(panels.get(panels.size)!.getId(), model.getRoot().getId(), DockLocation.BOTTOM, -1, false);\r\n    model.doAction(mv);\r\n\r\n    return model;\r\n}\r\n\r\n\r\n// 1. find the tabsets within the model and put them into a map based on their panel number\r\n// 2. for each panel, if its panel nr is larger than max panel then it needs to be deleted but not before...\r\n// 3. ...moving its children to their preferred destination specified in panelPreferences.\r\n// The child nodes are then moved to their new preferred / available panel\r\nexport const removeTabset = (model: Model, maxPanelNr?: number): Model => {\r\n    let maxPanel = -1;\r\n    const panels = new Map<number, TabSetNode>();\r\n\r\n\r\n    // first find out how many tabsets there are in the model and collect them in a map. \r\n    let panelNr = 1;\r\n    model.visitNodes((node) => {\r\n        if (node.getType() === 'tabset') {\r\n            const ts = node as TabSetNode;\r\n            panels.set(panelNr++, ts);\r\n        }\r\n    });\r\n    maxPanel = (maxPanelNr) ? maxPanelNr : panels.size;\r\n\r\n    if (panels.size < 2) {\r\n        // don't want to delete the last tabset, so bail out here\r\n        return model;\r\n    }\r\n\r\n    // Now delete the top N tabsets\r\n    // if this function is called without a maxPanelNr then that's just the last panel (e.g. 5)\r\n    // if this function is called with a maxPanelNr (cos we're loading a template and the user only wants e.g. 2 panels) then that could be more than 1\r\n\r\n    panels.forEach((ts, panelNr) => {\r\n        if (panelNr >= maxPanel) {\r\n            // move the children\r\n            const childrenToMove = new Map<TabNode, Destination>();\r\n            ts.getChildren().forEach((child) => {\r\n                if (child.getType() === 'tab') {\r\n                    const tab = child as TabNode;\r\n                    childrenToMove.set(tab, tabToDestination(tab, maxPanel - 1));\r\n                }\r\n            })\r\n\r\n            childrenToMove.forEach((dest, child) => {\r\n                let p = panels.get(dest.destMajor);\r\n                let mv;\r\n                if (p) {\r\n                    mv = Actions.moveNode(child.getId(), p!.getId(), DockLocation.CENTER, dest.destMinor - 1, (dest.destPref ? dest.destPref > 0 : false) /* +ve = selected */);\r\n                } else {\r\n                    // got to move it somewhere....then to root\r\n                    mv = Actions.moveNode(child.getId(), model.getRoot().getId(), DockLocation.CENTER, - 1, false);\r\n                }\r\n                model.doAction(mv);\r\n            })\r\n\r\n\r\n            // delete the tabset. Actually an empty tabset will not be rendered\r\n            // but this will confuse the task of finding next tab to remove\r\n            // so better to clean up\r\n            let del = Actions.deleteTabset(ts.getId());\r\n            model.doAction(del);\r\n        }\r\n    })\r\n\r\n    // With less tabsets, some other tabs might prefer to be moved\r\n    reorderTabs(model);\r\n    return model;\r\n}\r\n\r\n// move tabs if necessary so that they are all on their preferred panel, in the preferred order\r\nconst reorderTabs = (model: Model) => {\r\n    const panels = new Map<number, TabSetNode>();\r\n\r\n    // first find out how many tabsets there are in the model \r\n    let panelNr = 1;\r\n    model.visitNodes((node) => {\r\n        if (node.getType() === 'tabset') {\r\n            const ts = node as TabSetNode;\r\n            panels.set(panelNr++, ts);\r\n        }\r\n    });\r\n\r\n    // Now iterate through the tabs and see where to move them\r\n    const tabsToMove = new Map<TabNode, Destination>();\r\n    model.visitNodes((node) => {\r\n        if (node.getType() === 'tab') {\r\n            tabsToMove.set(node as TabNode, tabToDestination(node as TabNode, panels.size));\r\n        }\r\n    });\r\n\r\n\r\n    // now do the moves\r\n    tabsToMove.forEach((dest, tab) => {\r\n        let mv;\r\n\r\n        if (dest.destMajor !== 0) {\r\n            let p = panels.get(dest.destMajor);\r\n            // tabOrder is the number after the decimal point\r\n            if (p) {\r\n                mv = Actions.moveNode(tab.getId(), p!.getId(), DockLocation.CENTER, dest.destMinor - 1, (dest.destPref ? dest.destPref > 0 : false) /* +ve = selected */);\r\n                model.doAction(mv);\r\n            }\r\n        }\r\n\r\n    })\r\n\r\n\r\n}\r\n\r\n\r\n// use tab config to see, for the given max panel, where the tab should go\r\ntype Destination = {\r\n    destPref: number | undefined, // the original config value (can be negative or undefined)\r\n    destMajor: number, // 0 means unknown destination\r\n    destMinor: number\r\n}\r\nconst tabToDestination = (tab: TabNode, maxPanel: number = 5): Destination => {\r\n    let destPref;\r\n\r\n    if (tab.getConfig()?.panelPreferences?.length >= maxPanel) {\r\n        destPref = tab.getConfig().panelPreferences[maxPanel - 1];\r\n        const destMajor = Math.floor(Math.abs(destPref));\r\n        const destMinor = Math.round((Math.abs(destPref) === destMajor) ? 0 : (Math.abs(destPref) - destMajor) * 10);\r\n\r\n        return {\r\n            destPref,\r\n            destMajor,\r\n            destMinor\r\n        }\r\n    } else {\r\n        return {\r\n            destPref,\r\n            destMajor: 0,\r\n            destMinor: -1\r\n        }\r\n    }\r\n\r\n}","// Based on https://github.com/streamich/use-media\r\n// simplified for initial implementation\r\n// more research needed to identify best library for media queries, and to expand to be a global App feature in context\r\n// Streamich has some good features, but maybe there is something better\r\nimport React, { DependencyList, EffectCallback } from 'react';\r\n\r\nimport { useState, useEffect, useLayoutEffect } from 'react';\r\n\r\nexport type Effect = (effect: EffectCallback, deps?: DependencyList) => void;\r\n\r\nconst createUseMedia = (effect: Effect) => (\r\n    query: string,\r\n    defaultState = false,\r\n) => {\r\n    const [state, setState] = useState(defaultState);\r\n\r\n    effect(() => {\r\n        let mounted = true;\r\n        const mediaQueryList: MediaQueryList = window.matchMedia(query);\r\n\r\n        const onChange = () => {\r\n            if (!mounted) {\r\n                return;\r\n            }\r\n            setState(Boolean(mediaQueryList.matches));\r\n        };\r\n\r\n        mediaQueryList.addListener(onChange);\r\n        setState(mediaQueryList.matches);\r\n\r\n        return () => {\r\n            mounted = false;\r\n            mediaQueryList.removeListener(onChange);\r\n        };\r\n    }, [query]);\r\n\r\n    return state;\r\n};\r\n\r\nexport const useMedia = createUseMedia(useEffect);\r\nexport const useMediaLayout = createUseMedia(useLayoutEffect);\r\n\r\nexport default useMedia;","import { Model, IJsonModel, DockLocation } from 'flexlayout-react';\r\n\r\nimport { analyseModel, removeTabset, moveTabset, IAnalyzedModel } from './FlexModelUtils';\r\n\r\n\r\n\r\nvar taskTemplateLayout: { name: string, model: IJsonModel } = {\r\n    name: 'task1',\r\n    model: {\r\n        global: {\r\n            \"rootOrientationVertical\": false,\r\n            // \"tabSetEnableDivide\": false, // it keeps things simpler for moving tabs if all tabsets are labelled with a panel nr\r\n            // \"enableEdgeDock\": false, // otherwise the user can create new rows by dragging into the edge\r\n            //\"tabEnableClose\": false\r\n        }, // {tabSetEnableTabStrip:false}, // to have just splitters\r\n        layout: {\r\n            \"type\": \"row\",\r\n\r\n            \"children\": [\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"Comm\",\r\n                            \"component\": \"pdf\",\r\n                            \"enableClose\": false,\r\n                            \"config\": {\r\n                                \"text\": \"https://www.ibm.com/downloads/cas/GB8ZMQZ3#view=FitH\",\r\n                                \"minWidth\": 50,\r\n                                \"minHeight\": 350,\r\n                                \"panelPreferences\": [1.1, 1.1, 1.1, 1.1, 1.1]\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"Letter\",\r\n                            \"component\": \"pdf\",\r\n                            \"enableClose\": false,\r\n                            \"config\": {\r\n                                \"text\": \"https://ai.stanford.edu/~nilsson/MLBOOK.pdf#view=FitH\",\r\n                                \"minWidth\": 50,\r\n                                \"minHeight\": 350,\r\n                                \"panelPreferences\": [-1.3, -1.3, 2.1, 2.1, 2.1]\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"Claims\",\r\n                            \"component\": \"pdf\",\r\n                            \"enableClose\": false,\r\n                            \"config\": {\r\n                                \"text\": \"https://patentimages.storage.googleapis.com/68/80/73/6a17a66e9ec8c5/US11107588.pdf#view=FitH\",\r\n                                \"preferredWidth\": 200,\r\n                                \"minWidth\": 50,\r\n                                \"minHeight\": 350,\r\n                                \"panelPreferences\": [-1.4, -2.2, -3.2, 3.1, 3.1]\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"Fig\",\r\n                            \"component\": \"image\",\r\n                            \"enableClose\": false,\r\n                            \"config\": {\r\n                                \"text\": \"https://patentimages.storage.googleapis.com/US20060145019A1/US20060145019A1-20060706-D00000.png\",\r\n                                \"minWidth\": 250,\r\n                                \"minHeight\": 350,\r\n                                \"panelPreferences\": [-1.2, -1.2, -1.2, -1.2, 4.1]\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"width\": 1500,\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"AppAn\",\r\n                            \"component\": \"123check\",\r\n                            \"enableClose\": true,\r\n                            \"config\": {\r\n                                \"text\": \"/flexstack/123Check_only.png\",\r\n                                \"width\": 1280,\r\n                                \"minWidth\": 774,\r\n                                \"minHeight\": 350,\r\n                                \"panelPreferences\": [-1.5, 2.1, 3.1, 4.1, 5.1]\r\n                            }\r\n                        }\r\n                    ]\r\n                }\r\n            ]\r\n        }\r\n    }\r\n};\r\n\r\n\r\n\r\n// if maxPanel is undefined, return the canonical model (or in future the user's saved model if there is one, and the canonical model failing that)\r\n// if maxPanel is defined, transform the model \r\nexport const loadTemplateModel = (howToStack: DockLocation, maxPanel?: number) => {\r\n    let initialModel = Model.fromJson(taskTemplateLayout.model as IJsonModel);\r\n    let adaptedModel = initialModel;\r\n    let fullModel: IAnalyzedModel;\r\n\r\n\r\n    // if the caller has specified the nr of panels, then return a model that meets that requirement\r\n    if (maxPanel) {\r\n        if (howToStack === DockLocation.BOTTOM) {\r\n            adaptedModel = moveTabset(initialModel);\r\n        } else {\r\n            adaptedModel = removeTabset(initialModel, maxPanel + 1);\r\n        }\r\n        fullModel = analyseModel(adaptedModel, true, true);\r\n\r\n    } else { // I have to figure out myself how many panels fit the current viewport\r\n        const availableWidth = window.innerWidth;\r\n\r\n        console.log(\"avail width is \" + availableWidth)\r\n        let nrPanels = 5;\r\n\r\n        fullModel = analyseModel(initialModel, true, true);\r\n        let width = fullModel.width ? fullModel.width! : fullModel.widthNeeded!;\r\n        while (nrPanels > 1 && availableWidth < width) {\r\n            adaptedModel = removeTabset(fullModel.model, nrPanels);\r\n            fullModel = analyseModel(adaptedModel, true, true);\r\n            width = fullModel.width ? fullModel.width! : fullModel.widthNeeded!;\r\n            nrPanels--;\r\n        }\r\n\r\n    }\r\n\r\n    return fullModel;\r\n\r\n}","import React, { useEffect, useRef, useState } from 'react';\r\nimport './App.css';\r\nimport 'flexlayout-react/style/light.css'\r\n\r\nimport { Layout, Model, TabNode, Action, DockLocation } from 'flexlayout-react';\r\n\r\nimport { analyseModel, IAnalyzedModel, migrateModel, cloneModel, removeTabset, moveTabset } from './FlexModelUtils';\r\n\r\nimport useMedia from './hooks/useMediaQuery';\r\n\r\nimport { loadTemplateModel } from './LoadTemplate'\r\n\r\n\r\nfunction App() {\r\n  // currentModel is what we're currently rendering.\r\n  // If we need to alter the layout due to size restrictions, the previous state is saved in \"stashedModels\" so that it can be restored later\r\n  const [stashedModels, _setStashedModels] = useState<IAnalyzedModel[]>(() => {\r\n    // this is now hardocded but it should be deduced by analysing the template model for this task\r\n    const currentWidth = window.innerWidth;\r\n    let defaultNrPanels;\r\n    if (currentWidth > 1652) {\r\n      defaultNrPanels = 5;\r\n    } else if (currentWidth > 1652 - 50) {\r\n      defaultNrPanels = 4;\r\n    } else if (currentWidth > (1652 - 50) - 50) {\r\n      defaultNrPanels = 3;\r\n    } else if (currentWidth > ((1652 - 50) - 50) - 50) {\r\n      defaultNrPanels = 2;\r\n    } else {\r\n      defaultNrPanels = 1;\r\n    }\r\n    return [loadTemplateModel(DockLocation.CENTER)]\r\n  });\r\n  const [maxPanels, setMaxPanels] = useState(5);\r\n\r\n  const [canvasToggleAbs, setCanvasToggleAbs] = useState({ height: false, width: false });\r\n  const [stackStrategy, setStackStrategy] = useState('NONE');\r\n\r\n\r\n  const layoutRef = useRef(null);\r\n\r\n  const currentModel = stashedModels[stashedModels.length - 1];\r\n\r\n\r\n  const stashPop = () => {\r\n    const newStash = stashedModels.slice(0, -1);\r\n    _setStashedModels(newStash);\r\n  }\r\n\r\n  const stashSet = (model: IAnalyzedModel[]) => {\r\n    _setStashedModels(model);\r\n  }\r\n\r\n\r\n  const downsizeModel = (stackDirection: DockLocation) => {\r\n    let alteredModel = cloneModel(currentModel);\r\n    let previousModelWidth = alteredModel.widthNeeded;\r\n\r\n    const newStash = [...stashedModels];\r\n\r\n    do {\r\n      let m;\r\n      if (stackDirection === DockLocation.BOTTOM) {\r\n        m = moveTabset(alteredModel.model);\r\n      } else {\r\n        m = removeTabset(alteredModel.model);\r\n      }\r\n      alteredModel = analyseModel(m);\r\n\r\n\r\n      // if that helped, push altered model onto the stack\r\n      if (alteredModel.widthNeeded !== previousModelWidth) {\r\n        newStash.push(alteredModel);\r\n      }\r\n      alteredModel = cloneModel(alteredModel);\r\n    } while (alteredModel.widthNeeded !== previousModelWidth && alteredModel.widthNeeded! > window.innerWidth)\r\n    // keep removing tabsets until its narrow enough, or we're not making any further progress\r\n\r\n    // note: cannot use push in a loop because setState is asyncrhonous and only the last call to setState persists\r\n    stashSet(newStash);\r\n  }\r\n\r\n\r\n\r\n  // If the viewport is too narrow for the current model....\r\n  const isTooNarrow = useMedia(`(max-width: ${currentModel.widthNeeded}px)`);\r\n  useEffect(() => {\r\n\r\n    if (isTooNarrow) {\r\n      switch (stackStrategy) {\r\n/*         case 'X':\r\n          setCanvasToggleAbs({ height: false, width: true });\r\n          break;\r\n        case 'Y':\r\n          console.log(\"Y STACK\")\r\n          downsizeModel(DockLocation.BOTTOM);\r\n          break;\r\n */        case 'Z':\r\n          downsizeModel(DockLocation.CENTER);\r\n          setCanvasToggleAbs({ height: false, width: false });\r\n      }\r\n\r\n    } /* else if (stackStrategy === 'X') {\r\n      // No need for absolute width anymore\r\n      setCanvasToggleAbs({ height: false, width: false });\r\n    } */\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [isTooNarrow]);\r\n\r\n\r\n  // is the viewport now wide enough to switch back to the previous model?\r\n  const tooWide = stashedModels.length > 1 ? ((stashedModels[stashedModels.length - 2] as IAnalyzedModel).widthNeeded!) : 9999999999;\r\n  const isTooWide = useMedia(`(min-width: ${tooWide}px`);\r\n  useEffect(() => {\r\n\r\n    if (isTooWide) {\r\n      migrateModel(currentModel, stashedModels[stashedModels.length - 2]);\r\n      stashPop();\r\n    }\r\n\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [isTooWide]);\r\n\r\n\r\n\r\n  // If too short for current model switch to absolute, \r\n  /*   const isTooShort = useMedia(`(max-height: ${currentModel.heightNeeded}px)`);\r\n    useEffect(() => {\r\n      if (currentModel) {\r\n        if (!isTooShort) {\r\n          setCanvasToggleAbs({ height: false, width: canvasToggleAbs.width });\r\n        } else {\r\n          setCanvasToggleAbs({ height: true, width: canvasToggleAbs.width });\r\n        }\r\n      }\r\n      // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, [isTooShort]);\r\n  \r\n   */\r\n  const factory = (node: TabNode) => {\r\n    var component = node.getComponent();\r\n    if (component === \"text\") {\r\n      return <div dangerouslySetInnerHTML={{ __html: node.getConfig().text }} />\r\n    } else if (component === \"pdf\") {\r\n      const iStyles = {\r\n        height: '99%',\r\n        width: '99%',\r\n        overflow: 'hidden',\r\n        border: 'none'\r\n      }\r\n      const cont = {\r\n        height: '100%',\r\n        width: '100%',\r\n        overflow: 'hidden'\r\n      }\r\n      return <div style={cont}>  <iframe src={node.getConfig().text} className=\"invisible-scrollbar\" style={iStyles} scrolling=\"no\" /> </div>\r\n    } else if (component === \"image\") {\r\n      const s = {\r\n        height: '99%',\r\n        width: '99%'\r\n      }\r\n      return <img src={node.getConfig().text} style={s} />\r\n    } else if (component === \"123check\") {\r\n      const s = {\r\n        width: '1200px',\r\n        height: '1000px'\r\n      }\r\n      return <img src={node.getConfig().text} style={s} />\r\n    }\r\n  }\r\n\r\n  /*   const onAdd = (event: any) => {\r\n      (layoutRef.current! as Layout).addTabWithDragAndDropIndirect(\"Add panel<br>(Drag to location)\", {\r\n        component: \"text\",\r\n        name: \"added\",\r\n        config: { text: \"i was added\", minHeight: 300, minWidth: 400 }\r\n      }, undefined);\r\n    }\r\n   */\r\n  const interceptAction = (action: Action) => {\r\n\r\n    // when tabs are moved by the user, this can lead to a \"divide\" whereby a new tabset is created automatically for the tab\r\n    // this new tabset will not have a minimum size and so this needs to be set\r\n    // also for deletion of tabs or addition of nodes, the size may be impacted\r\n    setTimeout(() => {\r\n      stashedModels[stashedModels.length - 1] = analyseModel(currentModel.model, true /* update min sizes if needed*/);\r\n    }, 100);\r\n\r\n    return action;\r\n  }\r\n\r\n  /*   const changeStrategy = (event: any) => {\r\n      setCanvasToggleAbs({ height: false, width: false });\r\n      setStackStrategy(event.target.value);\r\n    }\r\n   */\r\n  const loadPanels = (event: any) => {\r\n    setMaxPanels(parseInt(event.target.value));\r\n    stashSet([loadTemplateModel(DockLocation.CENTER, parseInt(event.target.value))]);\r\n  }\r\n\r\n  const modelChanged = (model: Model) => {\r\n    stashedModels[stashedModels.length - 1] = analyseModel(currentModel.model, false /* avoid infintie loop*/);\r\n  }\r\n\r\n  const absStyle = {\r\n    height: canvasToggleAbs.height ? currentModel.heightNeeded + 'px' : '100%',\r\n    width: canvasToggleAbs.width ? currentModel.widthNeeded + 'px' : '100%'\r\n  };\r\n\r\n\r\n  return (\r\n    <div className=\"outer\" style={absStyle}>\r\n      {/*       <button onClick={onAdd}>Add Panel</button>\r\n      <span> Stacking strategy:</span>\r\n      <select value={stackStrategy} onChange={changeStrategy}>\r\n        <option value=\"X\">X axis</option>\r\n        <option value=\"Y\">Y axis</option>\r\n        <option value=\"Z\">Z axis</option>\r\n      </select>\r\n */}      <span> Number of Panels:</span>\r\n      <select value={maxPanels} onChange={loadPanels}>\r\n        <option value=\"1\">1</option>\r\n        <option value=\"2\">2</option>\r\n        <option value=\"3\">3</option>\r\n        <option value=\"4\">4</option>\r\n        <option value=\"5\">5</option>\r\n      </select>\r\n      <div className=\"inner\" >\r\n        {currentModel && (\r\n          <Layout ref={layoutRef}\r\n            onAction={interceptAction}\r\n            onModelChange={modelChanged}\r\n            model={currentModel.model}\r\n            factory={factory} />)}\r\n      </div>\r\n    </div>\r\n\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('container')\n);\n"],"sourceRoot":""}