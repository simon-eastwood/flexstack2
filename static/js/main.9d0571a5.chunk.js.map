{"version":3,"sources":["FlexModelUtils.ts","LoadTemplate.ts","App.tsx","index.tsx"],"names":["getConfig","tab","getType","TabNode","TYPE","Error","getId","max","dimension1","dimension2","result","Math","isNaN","setTabSetSize","tabset","updateIfNeeded","safeToSetWidth","minWidth","undefined","preferredWidth","width","getChildren","forEach","node","attrs","getMinWidth","currentWidth","getWidth","Object","keys","length","setSize","Actions","updateNodeAttributes","getModel","doAction","analyseRow","row","setWidth","tabsetChildren","filter","TabSetNode","getOrientation","Orientation","HORZ","ts","RowNode","childRowPreferredWidth","analyseModel","modelToAnalyse","alsoSetWidth","size","getRoot","model","console","log","removeTabset","maxPanelNr","maxPanel","panels","Map","panelNr","visitNodes","set","childrenToMove","child","tabToDestination","dest","mv","p","get","destMajor","moveNode","DockLocation","CENTER","destMinor","destPref","del","deleteTabset","reorderTabs","tabsToMove","panelPreferences","floor","abs","round","bundleExample","w2wTemplateLayout","global","layout","isEmpty","c","getComponent","loadTemplateModel","fullModel","initialModel","Array","template","Model","fromJson","push","bundle","bundleItem","mfeConfig","mfe","getMfeConfig","type","destinationPanel","newConfig","name","title","component","config","panel","getTemplate","adaptedModel","availableWidth","window","innerWidth","nrPanels","rms","deleteTab","action","rmEmptyTabs","App","useState","currentModel","setCurrentModel","maxPanels","setMaxPanels","className","value","onChange","event","parseInt","target","onAction","setTimeout","onModelChange","factory","dangerouslySetInnerHTML","__html","uri","style","height","overflow","src","border","scrolling","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.9d0571a5.chunk.js","sourcesContent":["import { Model, TabNode, TabSetNode, Orientation, Actions, Action, Node as FLNode, DockLocation, RowNode } from 'flexlayout-react';\r\nimport { IAnalyzedModel, IDimensions } from './types';\r\n\r\ninterface IConfig {\r\n    width: number | undefined,\r\n    minWidth: number | undefined,\r\n    panelPreferences: number[],\r\n    preferredWidth: number | undefined\r\n}\r\n\r\n// typesafe access to avoid typos in code\r\nconst getConfig = (tab: FLNode): IConfig => {\r\n    if (tab.getType() === TabNode.TYPE) {\r\n        return (tab as TabSetNode).getConfig() as IConfig;\r\n    } else {\r\n        throw Error(`Node ${tab.getId()} is not a tab and so does not have config`)\r\n    }\r\n}\r\n\r\n// return the max, taking into account that either or both might be undefined\r\nconst max = (dimension1: number | undefined, dimension2: number | undefined): number | undefined => {\r\n    let result = Math.max(dimension1!, dimension2!);\r\n    if (isNaN(result)) {\r\n        if (dimension1) return dimension1;\r\n        if (dimension2) return dimension2;\r\n        return undefined\r\n    } else {\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\nconst setTabSetSize = (tabset: TabSetNode, updateIfNeeded: boolean, safeToSetWidth: boolean = false): IDimensions => {\r\n    const result: IDimensions = {\r\n        minWidth: undefined,\r\n        preferredWidth: undefined,\r\n        width: undefined\r\n    };\r\n\r\n    // iterate through the tabs to get sizes\r\n    tabset.getChildren().forEach(node => {\r\n        if (node.getType() !== TabNode.TYPE) {\r\n            throw Error(\"tabset has a child which is not a tab - this is not expected\")\r\n        }\r\n\r\n        const tab = node as TabNode;\r\n\r\n        result.minWidth = max(result.minWidth, getConfig(tab)?.minWidth);\r\n        result.width = max(result.width, getConfig(tab)?.width);\r\n        result.preferredWidth = max(result.preferredWidth, getConfig(tab)?.preferredWidth);\r\n    })\r\n\r\n    if (!result.preferredWidth) {\r\n        if (result.width) {\r\n            result.preferredWidth = result.width;\r\n        } else {\r\n            result.preferredWidth = result.minWidth;\r\n        }\r\n    }\r\n\r\n    // to avoid infinite loops, updates cannot be done on model updates\r\n    if (updateIfNeeded) {\r\n        // only modify if different because this causes a model update which again causes analyse\r\n        type Attrs = {\r\n            minWidth?: number,\r\n            width?: number\r\n        };\r\n        const attrs: Attrs = {};\r\n        if (result.minWidth && result.minWidth > 0 && tabset.getMinWidth() !== result.minWidth) {\r\n            attrs.minWidth = result.minWidth;\r\n        }\r\n        const currentWidth = tabset.getWidth();\r\n        if (!safeToSetWidth && currentWidth) {\r\n            // Reset the width or there will be layout problems\r\n            attrs.width = 999999999;  // only way to clear an already-set width\r\n        } else if (!currentWidth && safeToSetWidth && result.width && currentWidth !== result.width) {\r\n            // if the current width is undefined (otherwise the user has set it and we'd better leave it alone)\r\n            // and it is safe to set the width (there are other tabsets to use free space)\r\n            // and there IS a width to set and its new\r\n            // only then: set the width\r\n            attrs.width = result.width;\r\n        }\r\n\r\n\r\n        // Now set the size information collated from the child tabs at the tabset level in the model\r\n        if (Object.keys(attrs).length > 0) {\r\n            const setSize = Actions.updateNodeAttributes(tabset.getId(), attrs);\r\n            tabset.getModel().doAction(setSize);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n// returns preferred width (defaulting to the min width if there is no prefferd) of all tabsets in the row\r\nconst analyseRow = (row: RowNode, updateIfNeeded: boolean, safeToSetWidth: boolean = false): number => {\r\n    let preferredWidth = 0;\r\n    let setWidth = false;\r\n\r\n    const tabsetChildren = row.getChildren().filter((node) => node.getType() === TabSetNode.TYPE);\r\n    if (tabsetChildren.length >= 2 && updateIfNeeded && row.getOrientation() === Orientation.HORZ) {\r\n        setWidth = true; // can only do this if there enough tabsets\r\n    }\r\n\r\n    row.getChildren().forEach(node => {\r\n        if (node.getType() === TabSetNode.TYPE) {\r\n            const ts = setTabSetSize(node as TabSetNode, updateIfNeeded, setWidth);\r\n\r\n            if (row.getOrientation() === Orientation.HORZ) {\r\n                preferredWidth += ts.preferredWidth ? ts.preferredWidth : ts.minWidth!;\r\n            } else {\r\n                preferredWidth = max(preferredWidth, ts.preferredWidth ? ts.preferredWidth : ts.minWidth)!;\r\n            }\r\n        } else if (node.getType() === RowNode.TYPE) {\r\n            // recurse for child row\r\n            const childRowPreferredWidth = analyseRow(node as RowNode, updateIfNeeded, setWidth);\r\n            if (row.getOrientation() === Orientation.HORZ) {\r\n                preferredWidth += childRowPreferredWidth;\r\n            } else {\r\n                preferredWidth = max(preferredWidth, childRowPreferredWidth)!;\r\n            }\r\n        }\r\n    })\r\n\r\n    return preferredWidth;\r\n}\r\n\r\nexport const analyseModel = (modelToAnalyse: Model, updateIfNeeded: boolean = true, alsoSetWidth: boolean = false): IAnalyzedModel => {\r\n\r\n    // call analyze row with root\r\n    const size = analyseRow(modelToAnalyse.getRoot(), updateIfNeeded, alsoSetWidth);\r\n\r\n    const result: IAnalyzedModel = {\r\n        model: modelToAnalyse,\r\n        preferredWidth: size\r\n    }\r\n\r\n    console.log(result);\r\n    return result;\r\n}\r\n\r\n\r\nexport const cloneModel = (modelToClone: IAnalyzedModel): IAnalyzedModel => {\r\n    let saveCurrentJson = modelToClone.model.toJson();\r\n    let clone = { ...modelToClone };\r\n    clone.model = Model.fromJson(saveCurrentJson);\r\n    return clone;\r\n}\r\n\r\n\r\n\r\n// 1. find the tabsets within the model and put them into a map based on their panel number\r\n// 2. for each panel, if its panel nr is larger than max panel then it needs to be deleted but not before...\r\n// 3. ...moving its children to their preferred destination specified in panelPreferences.\r\n// The child nodes are then moved to their new preferred / available panel\r\nexport const removeTabset = (model: Model, maxPanelNr?: number): Model => {\r\n    let maxPanel = -1;\r\n    const panels = new Map<number, TabSetNode>();\r\n\r\n\r\n    // first find out how many tabsets there are in the model and collect them in a map. \r\n    let panelNr = 1;\r\n    model.visitNodes((node) => {\r\n        if (node.getType() === 'tabset') {\r\n            const ts = node as TabSetNode;\r\n            panels.set(panelNr++, ts);\r\n        }\r\n    });\r\n    maxPanel = (maxPanelNr) ? maxPanelNr : panels.size;\r\n\r\n    if (panels.size < 2) {\r\n        // don't want to delete the last tabset, so bail out here\r\n        return model;\r\n    }\r\n\r\n    // Now delete the top N tabsets\r\n    // if this function is called without a maxPanelNr then that's just the last panel (e.g. 5)\r\n    // if this function is called with a maxPanelNr (cos we're loading a template and the user only wants e.g. 2 panels) then that could be more than 1\r\n\r\n    panels.forEach((ts, panelNr) => {\r\n        if (panelNr >= maxPanel) {\r\n            // move the children\r\n            const childrenToMove = new Map<TabNode, Destination>();\r\n            ts.getChildren().forEach((child) => {\r\n                if (child.getType() === 'tab') {\r\n                    const tab = child as TabNode;\r\n                    childrenToMove.set(tab, tabToDestination(tab, maxPanel - 1));\r\n                }\r\n            })\r\n\r\n            childrenToMove.forEach((dest, child) => {\r\n                let p = panels.get(dest.destMajor);\r\n                let mv;\r\n                if (p) {\r\n                    mv = Actions.moveNode(child.getId(), p!.getId(), DockLocation.CENTER, dest.destMinor - 1, (dest.destPref ? dest.destPref > 0 : false) /* +ve = selected */);\r\n                } else {\r\n                    // got to move it somewhere....then to root\r\n                    mv = Actions.moveNode(child.getId(), model.getRoot().getId(), DockLocation.CENTER, - 1, false);\r\n                }\r\n                model.doAction(mv);\r\n            })\r\n\r\n\r\n            // delete the tabset. Actually an empty tabset will not be rendered\r\n            // but this will confuse the task of finding next tab to remove\r\n            // so better to clean up\r\n            let del = Actions.deleteTabset(ts.getId());\r\n            model.doAction(del);\r\n        }\r\n    })\r\n\r\n    // With less tabsets, some other tabs might prefer to be moved\r\n    reorderTabs(model);\r\n    return model;\r\n}\r\n\r\n// move tabs if necessary so that they are all on their preferred panel, in the preferred order\r\nconst reorderTabs = (model: Model) => {\r\n    const panels = new Map<number, TabSetNode>();\r\n\r\n    // first find out how many tabsets there are in the model \r\n    let panelNr = 1;\r\n    model.visitNodes((node) => {\r\n        if (node.getType() === 'tabset') {\r\n            const ts = node as TabSetNode;\r\n            panels.set(panelNr++, ts);\r\n        }\r\n    });\r\n\r\n    // Now iterate through the tabs and see where to move them\r\n    const tabsToMove = new Map<TabNode, Destination>();\r\n    model.visitNodes((node) => {\r\n        if (node.getType() === 'tab') {\r\n            tabsToMove.set(node as TabNode, tabToDestination(node as TabNode, panels.size));\r\n        }\r\n    });\r\n\r\n\r\n    // now do the moves\r\n    tabsToMove.forEach((dest, tab) => {\r\n        let mv;\r\n\r\n        if (dest.destMajor !== 0) {\r\n            let p = panels.get(dest.destMajor);\r\n            // tabOrder is the number after the decimal point\r\n            if (p) {\r\n                mv = Actions.moveNode(tab.getId(), p!.getId(), DockLocation.CENTER, dest.destMinor - 1, (dest.destPref ? dest.destPref > 0 : false) /* +ve = selected */);\r\n                model.doAction(mv);\r\n            }\r\n        }\r\n\r\n    })\r\n\r\n\r\n}\r\n\r\n\r\n// use tab config to see, for the given max panel, where the tab should go\r\ntype Destination = {\r\n    destPref: number | undefined, // the original config value (can be negative or undefined)\r\n    destMajor: number, // 0 means unknown destination\r\n    destMinor: number\r\n}\r\nconst tabToDestination = (tab: TabNode, maxPanel: number = 5): Destination => {\r\n    let destPref;\r\n\r\n    if (getConfig(tab)?.panelPreferences?.length >= maxPanel) {\r\n        destPref = getConfig(tab).panelPreferences[maxPanel - 1];\r\n        const destMajor = Math.floor(Math.abs(destPref));\r\n        const destMinor = Math.round((Math.abs(destPref) === destMajor) ? 0 : (Math.abs(destPref) - destMajor) * 10);\r\n\r\n        return {\r\n            destPref,\r\n            destMajor,\r\n            destMinor\r\n        }\r\n    } else {\r\n        return {\r\n            destPref,\r\n            destMajor: 0,\r\n            destMinor: -1\r\n        }\r\n    }\r\n\r\n}","import { Model, IJsonModel, TabSetNode, TabNode, Actions, Node as FLNode, Action } from 'flexlayout-react';\r\n\r\nimport { analyseModel, removeTabset } from './FlexModelUtils';\r\nimport { IAnalyzedModel, IDimensions } from './types';\r\n\r\nconst bundleExample = {\r\n    \"id\": \"igra\",\r\n    \"bundle\": [\r\n        {\r\n            \"type\": \"pdf\",\r\n            \"uri\": \"https://www.ibm.com/downloads/cas/GB8ZMQZ3#view=FitH\",\r\n            \"title\": \"Communication\",\r\n            \"doPrecheck\": false,\r\n            \"panelPreferences\": [1.1, 1.1, 1.1, 1.1, 1.1]\r\n        },\r\n        {\r\n            \"type\": \"pdf\",\r\n            \"uri\": \"https://ai.stanford.edu/~nilsson/MLBOOK.pdf#view=FitH\",\r\n            \"title\": \"Letter\",\r\n            \"doPrechack\": false,\r\n            \"panelPreferences\": [-1.3, -1.3, 2.1, 2.1, 2.1]\r\n        },\r\n        {\r\n            \"type\": \"pdf\",\r\n            \"uri\": \"https://patentimages.storage.googleapis.com/68/80/73/6a17a66e9ec8c5/US11107588.pdf#view=FitH\",\r\n            \"title\": \"Claims\",\r\n            \"doPrechack\": false,\r\n            \"panelPreferences\": [-1.4, -2.2, -3.2, 3.1, 3.1]\r\n        },\r\n        {\r\n            \"type\": \"image\",\r\n            \"uri\": \"https://patentimages.storage.googleapis.com/US20060145019A1/US20060145019A1-20060706-D00000.png\",\r\n            \"title\": \"figure\",\r\n            \"doPrechack\": false,\r\n            \"panelPreferences\": [-1.2, -1.2, -1.2, -1.2, 4.1]\r\n        },\r\n        {\r\n            \"type\": \"123check\",\r\n            \"uri\": \"/flexstack2/123Check_only.png\",\r\n            \"title\": \"AppAn\",\r\n            \"doPrechack\": false,\r\n            \"panelPreferences\": [-1.5, 2.1, 3.1, 4.1, 5.1]\r\n        }\r\n\r\n\r\n    ]\r\n};\r\n\r\nconst w2wTemplateLayout: { name: string, model: IJsonModel } = {\r\n    name: 'w2w-template',\r\n    model: {\r\n        global: {\r\n            \"rootOrientationVertical\": false,\r\n            // \"tabSetEnableDivide\": false, // it keeps things simpler for moving tabs if all tabsets are labelled with a panel nr\r\n            // \"enableEdgeDock\": false, // otherwise the user can create new rows by dragging into the edge\r\n            //\"tabEnableClose\": false\r\n        }, // {tabSetEnableTabStrip:false}, // to have just splitters\r\n        layout: {\r\n            \"type\": \"row\",\r\n            \"children\": [\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"children\": [\r\n                        {\r\n                            \"name\": \"\",\r\n                            \"type\": \"tab\",\r\n                            \"component\": \"\",\r\n                            \"enableClose\": false,\r\n                            \"config\": {\r\n\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"\",\r\n                            \"component\": \"\",\r\n                            \"enableClose\": false,\r\n                            \"config\": {\r\n\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"\",\r\n                            \"component\": \"\",\r\n                            \"enableClose\": false,\r\n                            \"config\": {\r\n\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"\",\r\n                            \"component\": \"\",\r\n                            \"enableClose\": false,\r\n                            \"config\": {\r\n                            }\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    \"type\": \"tabset\",\r\n                    \"selected\": 0,\r\n                    \"children\": [\r\n                        {\r\n                            \"type\": \"tab\",\r\n                            \"name\": \"\",\r\n                            \"component\": \"\",\r\n                            \"enableClose\": true,\r\n                            \"config\": {\r\n\r\n                            }\r\n                        }\r\n                    ]\r\n                }\r\n            ]\r\n        }\r\n    }\r\n};\r\n\r\n\r\nconst getMfeConfig = (mfe: string): IDimensions => {\r\n    // hard coded for now....\r\n\r\n    switch (mfe) {\r\n        case 'pdf':\r\n            return {\r\n                minWidth: 50,\r\n                preferredWidth: undefined,\r\n                width: undefined\r\n            }\r\n            break;\r\n        case '123check':\r\n            return {\r\n                minWidth: 774,\r\n                preferredWidth: 1280,\r\n                width: 1280\r\n            }\r\n\r\n            break;\r\n        case 'image':\r\n            return {\r\n                minWidth: 250,\r\n                preferredWidth: undefined,\r\n                width: undefined\r\n            }\r\n\r\n            break;\r\n        default:\r\n            return {\r\n                minWidth: undefined,\r\n                preferredWidth: undefined,\r\n                width: undefined\r\n            }\r\n            break;\r\n    }\r\n}\r\n\r\n\r\nconst isEmpty = (tab: TabNode): boolean => {\r\n    const c = tab.getComponent();\r\n    const check = !c || c.length === 0;\r\n    return check;\r\n}\r\n\r\n\r\nconst getTemplate = (): Model => {\r\n    const panels = new Array<TabNode>();\r\n\r\n    const template = Model.fromJson(w2wTemplateLayout.model);\r\n\r\n    template.visitNodes((node) => {\r\n        if (node.getType() === TabNode.TYPE) {\r\n            const tab = node as TabNode;\r\n            if (isEmpty(tab)) {\r\n                panels.push(tab);\r\n            }\r\n        }\r\n    });\r\n\r\n    bundleExample.bundle.forEach((bundleItem) => {\r\n        const destPref = bundleItem.panelPreferences[panels.length - 1];\r\n        const destMajor = Math.floor(Math.abs(destPref));\r\n        const destMinor = Math.round((Math.abs(destPref) === destMajor) ? 0 : (Math.abs(destPref) - destMajor) * 10);\r\n        const mfeConfig = getMfeConfig(bundleItem.type);\r\n\r\n        let destinationPanel = panels[0]; // default\r\n        if (destMajor <= panels.length) {\r\n            destinationPanel = panels[destMajor - 1];\r\n        }\r\n\r\n        const newConfig = { ...destinationPanel.getConfig(), ...mfeConfig, ...bundleItem };\r\n\r\n        const attrs = {\r\n            name: bundleItem.title,\r\n            component: bundleItem.type,\r\n            config: newConfig\r\n        };\r\n        const set = Actions.updateNodeAttributes(destinationPanel.getId(), attrs);\r\n        template.doAction(set);\r\n    });\r\n\r\n    panels.forEach(panel => console.log(panel));\r\n\r\n    return template;\r\n}\r\n\r\n\r\nconst rmEmptyTabs = (model: Model) => {\r\n    const rms = new Array<Action>();\r\n    console.log(\"deleting\");\r\n    model.visitNodes(node => {\r\n        if (node.getType() === TabNode.TYPE && isEmpty(node as TabNode)) {\r\n            rms.push(Actions.deleteTab(node.getId()))\r\n        }\r\n    });\r\n    rms.forEach(action => model.doAction(action));\r\n}\r\n\r\n// if maxPanel is undefined, return the canonical model (or in future the user's saved model if there is one, and the canonical model failing that)\r\n// if maxPanel is defined, transform the model \r\nexport const loadTemplateModel = (maxPanel?: number) => {\r\n    let initialModel = getTemplate();\r\n    let adaptedModel = initialModel;\r\n    let fullModel: IAnalyzedModel;\r\n\r\n\r\n    // if the caller has specified the nr of panels, then return a model that meets that requirement\r\n    if (maxPanel) {\r\n        adaptedModel = removeTabset(initialModel, maxPanel + 1);\r\n\r\n        fullModel = analyseModel(adaptedModel, true, true);\r\n\r\n    } else { // I have to figure out myself how many panels fit the current viewport\r\n        const availableWidth = window.innerWidth;\r\n\r\n\r\n        fullModel = analyseModel(initialModel, true, true);\r\n        // see how many panels there are in the full model\r\n        let nrPanels = 0;\r\n        fullModel.model.visitNodes((node) => { if (node.getType() === TabSetNode.TYPE) nrPanels++ });\r\n\r\n        // remove tabset one by one until it fits\r\n        while (nrPanels > 1 && availableWidth < fullModel.preferredWidth) {\r\n            adaptedModel = removeTabset(fullModel.model, nrPanels);\r\n            fullModel = analyseModel(adaptedModel, true, true);\r\n            nrPanels--;\r\n        }\r\n\r\n    }\r\n\r\n    // Now that all the processing has finished,\r\n    // delete any empty tabsets in case some panels were not used by the bundle\r\n    rmEmptyTabs(fullModel.model);\r\n\r\n\r\n    // removing empty tabs will not impact the dimensions, so no need to recalculate\r\n    return fullModel;\r\n\r\n}","import React, { useEffect, useRef, useState } from 'react';\r\nimport './App.css';\r\nimport 'flexlayout-react/style/light.css'\r\n\r\nimport { Layout, Model, TabNode, Action, DockLocation } from 'flexlayout-react';\r\n\r\nimport { analyseModel } from './FlexModelUtils';\r\n\r\n\r\nimport { loadTemplateModel } from './LoadTemplate'\r\nimport { IAnalyzedModel } from './types';\r\n\r\n\r\nfunction App() {\r\n  // currentModel is what we're currently rendering.\r\n  // If we need to alter the layout due to size restrictions, the previous state is saved in \"stashedModels\" so that it can be restored later\r\n  const [currentModel, setCurrentModel] = useState<IAnalyzedModel>(() => {\r\n    return loadTemplateModel()\r\n  });\r\n  const [maxPanels, setMaxPanels] = useState(5);\r\n\r\n  const factory = (node: TabNode) => {\r\n    var component = node.getComponent();\r\n    if (component === \"text\") {\r\n      return <div dangerouslySetInnerHTML={{ __html: node.getConfig().uri }} />\r\n    } else if (component === \"pdf\") {\r\n      const iStyles = {\r\n        height: '99%',\r\n        width: '99%',\r\n        overflow: 'hidden',\r\n        border: 'none'\r\n      }\r\n      const cont = {\r\n        height: '100%',\r\n        width: '100%',\r\n        overflow: 'hidden'\r\n      }\r\n      return <div style={cont}>  <iframe src={node.getConfig().uri} className=\"invisible-scrollbar\" style={iStyles} scrolling=\"no\" /> </div>\r\n    } else if (component === \"image\") {\r\n      const s = {\r\n        height: '99%',\r\n        width: '99%'\r\n      }\r\n      return <img src={node.getConfig().uri} style={s} />\r\n    } else if (component === \"123check\") {\r\n      const s = {\r\n        width: '1200px',\r\n        height: '1000px'\r\n      }\r\n      return <img src={node.getConfig().uri} style={s} />\r\n    }\r\n  }\r\n\r\n  const interceptAction = (action: Action) => {\r\n\r\n    // when tabs are moved by the user, this can lead to a \"divide\" whereby a new tabset is created automatically for the tab\r\n    // this new tabset will not have a minimum size and so this needs to be set\r\n    // also for deletion of tabs or addition of nodes, the size may be impacted\r\n    setTimeout(() => {\r\n      setCurrentModel(analyseModel(currentModel.model, true /* update min sizes if needed*/));\r\n    }, 100);\r\n\r\n    return action;\r\n  }\r\n\r\n  const loadPanels = (event: any) => {\r\n    setMaxPanels(parseInt(event.target.value));\r\n    setCurrentModel(loadTemplateModel(parseInt(event.target.value)));\r\n  }\r\n\r\n  const modelChanged = (model: Model) => {\r\n    setCurrentModel(analyseModel(currentModel.model, false /* avoid infintie loop*/))\r\n  }\r\n\r\n\r\n\r\n\r\n  return (\r\n    <div className=\"outer\">\r\n      <span> Number of Panels:</span>\r\n      <select value={maxPanels} onChange={loadPanels}>\r\n        <option value=\"1\">1</option>\r\n        <option value=\"2\">2</option>\r\n        <option value=\"3\">3</option>\r\n        <option value=\"4\">4</option>\r\n        <option value=\"5\">5</option>\r\n      </select>\r\n      <div className=\"inner\" >\r\n        {currentModel && (\r\n          <Layout\r\n            onAction={interceptAction}\r\n            onModelChange={modelChanged}\r\n            model={currentModel.model}\r\n            factory={factory} />)}\r\n      </div>\r\n    </div>\r\n\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('container')\n);\n"],"sourceRoot":""}